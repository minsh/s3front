#!/usr/bin/env node

/**
 * Module dependencies.
 */

var program     = require('commander')
  , pkg         = require('../package.json')
  , version     = pkg.version
  , knox        = require('knox')
  , wrench      = require('wrench')
  , fs          = require('fs')
  , inspect     = require('eyes').inspector({maxLength: -1})
  , ProgressBar = require('progress')
  , async       = require('async')
  , cloudfront  = require('cloudfront')
  , uuid        = require('node-uuid')
  ;

/* CLI */

program
  .version(version)
  .option('-k, --key <key>',        'aws key access id')
  .option('-s, --secret <secret>',  'aws secret access key')
  .option('-b, --bucket <name>',    'bucket name')
  .option('-q, --quiet',            'quiet mode')
  .option('-i, --invalidate',       'after upload find first cloudfront distribution which has an alias similar to the bucket name and invalidates its content')
  .parse(process.argv);

/* ensure required parameters */
if (!program.key) throw new Error('--key required');
if (!program.secret) throw new Error('--secret required');
if (!program.bucket) throw new Error('--bucket required');

console.log('\n');

/* s3 is our client to the specified bucket */
var s3 = knox.createClient({
    key:program.key
  , secret:program.secret
  , bucket:program.bucket
});

/* get all files and directory */
var files = wrench.readdirSyncRecursive('.');
/* remove directories */
files = files.filter(function(f){
  return !fs.statSync(f).isDirectory();
});

var quiet = (program.quiet) ? true : false;

var l = files.length;

/* setup progress bar */
var bar = new ProgressBar('  uploading [:bar] :percent :etas', {
    complete: '='
  , incomplete: ' '
  , width: 80
  , total: l
});

/* upload files by batch */
var batchSize = 10
  , tasks = []
  , cnt = 0
  , i = 0
  ;
while(true){
  var innerTasks = [];
  for (var j=i; j < i+batchSize && i < l; ++j, ++i){
    innerTasks.push(function(cb){
      var f = files[cnt++];
      s3.putFile(f, '/'+f, { 'x-amz-acl': 'public-read' }, function(err, res){
        if (err) return cb(err);
        if (res.statusCode!==200) console.log(res.statusCode,f);
        if (!quiet) bar.tick();
        cb();
      });
    });
  }
  tasks.push(function(cb){
    async.parallel(innerTasks, function(err){
      cb(err);
    });
  });
  if (i>=l) break;
}
async.series(tasks, function(err){
  if (err) {
    inspect(err);
    process.exit();
  }

  /* cloudfront invalidation */
  if (program.invalidate){
    var cf = cloudfront.createClient(program.key, program.secret);
    cf.listDistributions(function(err, list, info) {
      var distributionId = null;
      /* find first distribution id which has an alias similar to bucket name. */
      list.some(function(d){
        return d.config.aliases.some(function(a){
          if (a === program.bucket) {
            distributionId = d.id;
            return true;
          }
        });
      });
      /* invalidate content if distribution has been found */
      if (distributionId) {
        cf.createInvalidation(distributionId, uuid.v4(), '/.', function(err, invalidation){
          if (err) inspect(err)
          console.log('\n\ninvalidation status:',invalidation.status);
          process.exit();
        });
      }
    });
  } else {
    process.exit();
  }
});

process.on('exit', function(){
  console.log('\n');
});

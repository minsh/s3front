#!/usr/bin/env node

'use strict';

var program = require('commander');
var pkg = require('../package.json');
var version = pkg.version;
var s3 = require('s3');
var AWS = require('aws-sdk');
var wrench = require('wrench');
var fs = require('fs-extra');
var inspect = require('eyes').inspector({maxLength: -1});
var ProgressBar = require('progress');
var async = require('async');
var cloudfront = require('cloudfront');
var uuid = require('node-uuid');
var _ = require('underscore');
var cache = require('../lib/cache');

/* CLI */

program
  .version(version)
  .option('-k, --key <key>',                  'aws key access id')
  .option('-s, --secret <secret>',            'aws secret access key')
  .option('-b, --bucket <name>',              'bucket name')
  .option('-q, --quiet',                      'quiet mode')
  .option('-r, --region <name>',              'region if not in US standard')
  .option('-c, --cachecontrol <stringvalue>', 'cache control aws putObject param')
  .option('-i, --invalidate',                 'after upload find first cloudfront distribution which has an alias similar to the bucket name and invalidates its content')
  .parse(process.argv);

/* ensure required parameters */
if (!program.key) throw new Error('--key required');
if (!program.secret) throw new Error('--secret required');
if (!program.bucket) throw new Error('--bucket required');

console.log('\n');

cache.init(program.bucket);

program.region = program.region || 'us-east-1';

/* use newest sdk to avoid: https://github.com/andrewrk/node-s3-client/issues/69 */
var awsS3Client = new AWS.S3({
  accessKeyId: program.key,
  secretAccessKey: program.secret,
  region: program.region,
  signatureVersion: program.region === 'us-east-1' ? 'v2' : 'v4'
});

var s3Client = s3.createClient({s3Client: awsS3Client});

/* get all files and directory */
var files = wrench.readdirSyncRecursive('.');
/* remove directories */
files = files.filter(function(f){ return !fs.statSync(f).isDirectory(); });
var nbFiles = files.length;

var quiet = (program.quiet) ? true : false;

/* setup progress bar */
var bar = new ProgressBar('  uploading [:bar] :percent :etas', {complete: '=', incomplete: ' ', width: 40, total: nbFiles});

/* upload files by batch */
var batchSize = 10;
var cnt = 0;
var uploadCnt = 0;
var tasks = [];

var testCnt = 0;
_.range(Math.ceil(nbFiles / batchSize)).forEach(function(idx) {
  tasks.push(function(cb) {
    var uploads = [];
    for ( ; cnt < (idx + 1) * batchSize && cnt < nbFiles; ++cnt){
      uploads.push(function(cb){
        var file = files[uploadCnt++];
        cache.is(file, function(there) {
          if (there) { 
            if (!quiet) { bar.tick(); }
            return cb(); 
          }

          var params = {
            localFile: file,
            s3Params: {
              Bucket: program.bucket,
              Key: file,
              ACL: 'public-read'
            },
          };
          if (program.cachecontrol) {
            params.s3Params['CacheControl'] = program.cachecontrol;
          }
          var uploader = s3Client.uploadFile(params);
          uploader.on('error', cb);
          uploader.on('end', function() {
            cache.uploaded(file);
            if (!quiet) { bar.tick(); }
            return cb();
          });
        });
      });
    }
    async.parallel(uploads, function(err){ cb(err); });
  });
});

async.series(tasks, function(err){
  if (err) {
    inspect(err);
    process.exit();
  }

  /* cloudfront invalidation */
  if (program.invalidate){
    var cf = cloudfront.createClient(program.key, program.secret);
    cf.listDistributions(function(err, list, info) {
      var distributionId = null;
      /* find first distribution id which has an alias similar to bucket name. */
      list.some(function(d){
        return d.config.aliases.some(function(a){
          if (a === program.bucket) {
            distributionId = d.id;
            return true;
          }
        });
      });
      /* invalidate content if distribution has been found */
      if (distributionId) {
        cf.createInvalidation(distributionId, uuid.v4(), '/.', function(err, invalidation){
          if (err) inspect(err)
          console.log('\n\n  invalidation status:',invalidation.status);
          process.exit();
        });
      }
    });
  } else {
    process.exit();
  }
});

process.on('exit', function() { console.log('\n'); });
